### 컬렉션 팩토리

```java
import java.util.ArrayList;
import java.util.Arrays;
import java.util.Map;

class CollectionFactory {

    public static void main(String[] args) {
        List<String> friends = new ArrayList<>();
        friends.add("친구1");
        friends.add("친구2");
        friends.add("친구3");

        // 1. 리스트 팩토리
        // 팩토리 메서드 사용 -> Arrays.asList()
        // Arrays.asList()는 컬렉션이 의도하지 않게 변하는 것을 막귀위해서 사이즈가 정해져있다.
        List<String> friends = Arrays.asList("친구1", "친구2", "친구3");
        friends.add("친구4"); // UnsupportedOperationException 발생

        // 2. 집합 팩토리
        Set<String> friends = Set.of("친구1", "친구2", "친구3");

        // 3. 맵 팩토리
        Map<String, Integer> ageOfFriends = Map.of("친구1", 20, "친구2", 21, "친구3", 22);
        Map<String, Integer> ageOfFriends = Map.ofEntries(entry("친구1", 20), entry("친구1", 20), entry("친구1", 20));
    }
}
```

### 리스트와 집합 처리

- removeIf : 프레디케이트를 만족하는 요소를 제거한다. - List, Set 둘다 가능
- replaceAll : UnaryOperator 함수를 이요해 요소를 바꾼다. - List만 가능
- sort : List 인터페이스에서 제공하는 기능으로 리스트를 정렬한다. - List만 가능

```java
import java.util.stream.Collectors;

class ListSetAction {

    public static void main(String[] args) {

        // removeIf
        for (Transaction transaction : transactions) {
            if (Character.isDigit(transaction.getReferenceCode().charAt(0))) {
                transactions.remove(transaction);
            }
        }

        transactions.removeIf(transaction -> Character.isDigit(transaction.getReferenceCode().charAt(0)));

        // replaceAll

        referenceCodes.stream().map(code -> Character.toUpperCase(code.charAt(0)) +
                        code.substring(1))
                .collect(Collectors.toList())
                .forEach(System.out::println);

        referenceCodes.replaceAll(code -> Character.toUpperCase(code.charAt(0)) + code.substring(1));

    }
}
```

### 맵처리

```java
import java.util.Map;

class MapAction {

    public static void main(String[] args) {
        // forEach
        for (Map.Entry<String, Integer> entry : ageOfFriends.entrySet()) {
            String friend = entry.getKey();
            Integer age = entry.getValue();
            System.out.println("friend = " + friend + "age = " + age);
        }

        ageOfFriends.forEach((friend, age) -> System.out.println("friend = " + friend + "age = " + age));

        // 정렬
        ageOfFriends
                .entrySet()
                .stream()
                .sorted(Entry.comparingByKey())
                .forEachOrdered(System.out::println);
        
        // getOrDefault
        ageOfFriends.getOrDefault("친구999", "대신 나왔다."); // 키가 없을떄 NullPointException 방지를 위해서 기본값을 나오게함
        
        // 계산 패턴
        // 1. computeIfAbsent : 제공된 키에 해당하는 값이 없으면, 키를 이용해 새 값을 계산하고 맵에 추가한다.
        // 2. computeIfPresent : 제공된 키가 존재하면 새 값을 계산하고 맵에 추가한다.
        // 3. compute : 제공된 키로 새 값을 계산하고 맵에 저장한다.
        
        // 교체 패턴
        // 1. replaceAll : BiFunction을 적용한 결과로 각 항목의 값을 교체한다.
        // 2. Replace : 키가 존재하면 맵의 값을 바꾼다.
        
        // 합침
        // putAll
    }
}
```