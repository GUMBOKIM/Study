SOLID 원칙의 목적
1. 변경에 유연하다.
2. 이해하기 쉽다.
3. 많은 소프트웨어 시스템에 사용될 수 있는 컴포넌트의 기반이 된다.

### 7. SRP : 단일 책임 원칙
`단일 모듈은 오직 하나의 행동에 대해서만 책임져야 한다.`

#### 징후 1: 우발적 중복
서로 다른 액터가 의존하는 코드를 서로 분리해야한다.
-> 중복을 제거하기 위해서, 서로 다른 액터가 의존하는 코드를 너무 가까이 배치하면 안된다.

#### 징후 2: 병합
서로 다른 액터를 뒷받침하는 코드를 서로 분리해야 한다.  
해결책 : 모두 각기 다른 클래스로 이동 & 퍼사드 패턴

### 8. OCP : 개방-폐쇄 원칙
`소프트웨어 개체는 확장에 열려 있어야 하고, 변경에는 닫혀 있어야한다.`

1. 서로 다른 목적으로 변경되는 요소를 적절하게 분리(SRP)
2. 요소 사이의 의존성을 체계화 함(DIP) - 컴포넌트 관계는 단방향으로만 이뤄진다  

OCP의 목표는 시스템을 확장하기 쉬운 동시에 변경으로 인해 시스템이 너무 많은 영향을 받지 않도록 하는 것  
시스템을 컴포넌트 단위로 분리하고, 저수준 컴포넌트에서 발생한 변경으로부터 고수준 컴포넌트를 보호할수 있는 형태의 의존성 계층구조가 만들어져야한다.  

### 9. LSP : 리스코프 치환 원칙

### 10. ISP : 인터페이스 분리 원칙

### 11. DIP : 의존성 역전 원칙
`의존성이 추상에 의존하며 구체에는 의존하지 않는 시스템`  
의존하지 않도록 피하고자 하는 것은 변통성이 큰 구체적 요소이다.  

#### 안정된 추상화
- 변동성이 큰 구체 클래스를 참조하지 말라
- 변동성이 큰 구체 클래스로부터 파생하지 말라
- 구체 함수를 오버라이드 하지 말라
- 구체적이며 변동성이 크다면 절대로 그 이름을 언급하지 말라