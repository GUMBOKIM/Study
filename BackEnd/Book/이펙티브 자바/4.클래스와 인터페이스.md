### 아이템 15 : 클래스와 멤버의 접근 권한을 최소화하라

어설프게 설계된 컴포넌트와 잘 설계된 컴포넌트의 가장 큰 차이는 '내부 데이터와 내부 구현 정보를 얼마나 잘 숨겼는가'이다.  
-> 정보은닉, 캡슐화

정보 은닉의 장점
- 시스템 개발 속도를 높인다. 여러 컴포넌트를 병렬로 개발할 수 있기 때문이다.
- 시스템 관리 비용을 낮춘다. 각 컴포넌트를 더 빨리 파악하여 디버깅할 수 있고,
다른 컴포넌트로 교체하는 부담도 적기 때문이다.
- 정보 은닉 자체가 성능을 높여주지는 않지만, 성능 최적화에 도움을 준다.
완성된 시스템을 프로파일링해 최적화할 컴포넌트를 정한 다음,
다른 컴포넌트에 영향을 주지 않고 해당 컴포넌트만 최적화할 수 있기 때문이다.
- 소프트웨어 재사용성을 높인다.
외부에 거의 의존하지 않고 독자적으로 동작할 수 있는 컴포넌트라면,
그 컴포넌트와 함께 개발되지 않은 낯선 환경에서도 유용하게 쓰일 가능성이 크기 때문이다.
- 큰 시스템을 제작하는 난이도를 낮춰준다.
시스템 전체가 아직 완성되지 않은 상태에서도 개별 컴포넌트의 동작을 검증할 수 있기 때문이다.

**기본 원칙은 모든 클래스와 멤버의 접근성을 가능한 한 좁히는 것**


### 아이템 16 : public 클래스에서는 public 필드가 아닌 접근자 메서드를 사용하라

```java
class People {
    public String name;
    public int age;
}

class People {
    private String name;
    private int age;
    
    public Point(String name, int age){
        this.name = name;
        this.age = age;
    }
    
    public String getName() {return name;}
    public int getAge() {return age;}

    public void setName(String name) {return this.name;}
    public void setAge(int age) {return this.age;}
}
```


### 아이템 17 : 변경 가능성을 최소화 하라

클래스를 불변으로 만들기 위한 규칙
- 객체의 상태를 변경하는 메서드(변경자)를 제공하지 않는다.
- 클래스를 확장할 수 없도록 한다.
- 모든 필드를 final로 선언한다.
- 모든 필드를 private로 선언한다.
- 자신 외에는 내부의 가변 컴포넌트에 접근할 수 없도록 한다.

```java
public class Complex {
    private final double re;
    private final double im;
    
    private Complex(double re, double im){
        this.re = re;
        this.im = im;
    }
    
    .....
}
```

장점
1. 단순하다.
2. 스레드 안전하여 따로 동기화할 필요 없다.
3. 안심하고 공유할 수 있다.
4. 자유롭게 공유할 수 있음은 물론, 불변 객체끼리는 내부 데이터를 공유할 수 있다.
5. 객체를 만들 때 다른 불변 객체들을 구성요소로 사용하면 이점이 많다.
6. 실패 원자성을 제공한다. -> 예외가 발생한 후에도 객체는 예외 전과 똑같은 상태  
단점
7. 값이 다르면 반드시 독립된 객체로 만들어야한다.

불변으로 만들 수 없는 클래스라도 변경할 수 있는 부분을 최소한으로 줄이자!  
다른 합당한 이유가 없다면 모든 필드는 private final이어야 한다.  
생성자는 불변식 설정이 모두 완료된, 초기화가 완벽히 끝난 상태의 객체를 생성해야한다.


### 아이템 18 : 상속보다는 컴포지션을 사용하라

메서드 호출과 달리 상속은 캡슐화를 깨트린다.


**-> 더 공부하기(WrapperClass)**

### 아이템 19 : 상속을 고려해 설계하고 문서화하라. 그러지 않았다면 상속을 금지하라

- 상속용 클래스는 재정의할 수 있는 메서드들을 내부적으로 어떻게 이용하는지(자기 사용) 문서로 남겨야한다.
- 상속용 클래스를 시험하는 방법은 직접 하위 클래스를 만들어보는 것이 '유일'하다.
- 상속용으로 설계한 클래스는 배포전에 반드시 하위 클래스를 만들어 검증해야한다.
- 클래스를 상속용으로 설계하려면 엄청나 논력이 들고 그 클래스에 안기는 제약도 상당하다.
- 상속용으로 설계하지 않은 클래스는 상속을 금지하는 것이다.

### 아이템 20 : 추상 클래스보다는 인터페이스를 우선하라


상속은 기존 클래스에도 새로운 인터페이스를 구현해 넣을 수 있다. 인터페이스는 믹스인(mix in) 정의에 알맞춤이다.  
-> 믹스인은 클래스가 구현할 수 있는 타입  
인터페이스로는 계층구조가 없는 타입 프레임워크를 만들 수 있다.  
-> n개의 인터페이스로 정의 가능 2^n개의 클래스 구현가능  
인터페이스는 기능을 향삭시키는 안전하고 강력한 수단이 된다.

### 아이템 21 : 인터페이스는 구현하는 쪽을 생각해 설계하라

생각할 수 있는 모든 상황에서 불변식을 해치지 않는 디폴트 메서드를 작성하기는 어려움  
-> 디폴트 메서드는 기존 구현체에 런타임 오류를 일으킬 수 있다.  
-> 인터페이스를 설계할 때는 여전히 세심한 주의를 기울여야 한다.  
-> 인터페이스를 릴리스한 후라도 결함을 수정하는 게 가능한 경우도 있겠지만, 절대 그 가능성에 기대서는 안된다.


### 아이템 22 : 인터페이스는 타입을 정의하는 용도로만 사용하라

인터페이스는 자신을 구현한 클래스의 인스턴스를 참조할 수 있는 타입 역할을 한다.  
-> 상수 공개용 수단으로 사용하지 말자.

### 아이템 23 : 태그 달린 클래스보다는 클래스 계층 구조를 활용하라

태그 달린 클래스 -> 뚜 가지 이상의 의미를 표현할 수 있으며, 표현하는 의미를 대그 값으로 알려주는 클래스  
태그 달린 클래스는 장황하고, 오류를 내기 쉽고, 비효율적 => 클래스 계층 구조를 어설프게 흉내낸 아류  
태그 달린 클래스를 사용하기 보다는 계층 구조로 리팩토링해 사용하자

### 아이템 24 : 멤버 클래스는 되도록 static으로 만들라

중첩 클래스(내부, 정적 내부, 지역, 익명)  
1. 메서드 밖에서도 사용해야 하거나 메서드 안에 정의하기에 너무 길다면 내부 클래스로 만든다.  
  인스턴스 각각이 바깥 인스턴스를 참조한다면 비정적으로, 그렇지 않으면 정적으로 만들자.
2. 중첩 클래스가 한 메서드 안에서만 쓰이면서 그 인스턴스를 생성하는 지점이 단 한 곳이고  
해당 타입으로 쓰기에 적합한 클래스나 인터페이스가 이미 있다면 익명클래스, 아니면 지역 클래스로 만들자.

### 아이템 25 : 톱레벨 클래스는 한 파일에 하나만 담으라

소스 파일 하나에는 반드시 톱레벨 클래스(혹은 톱레벨 인터페이스)를 하나만 담자  
=> 같은 이름으로 정의하면 컴파일 오류가 생김