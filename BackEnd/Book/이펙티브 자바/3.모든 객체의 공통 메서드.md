### 아이템 10 : equals는 일반 규약을 지켜 재정의하라

아래와 같은 상황에서는 재정의하지 않는 것이 최선이다.
- 각 인스턴스가 본질적으로 교유하다.
- 인스턴스의 '논리적 동치성'을 검사할 일이 없다.
- 상위 클래스에서 재정의한 equals 가 하위 클래스에도 딱 들어 맞는다.
- 클래스가 private 이거나 package-private 이고 equals 메소드를 호출할 일이 없다.
```java
// 실수로라도 호출되는 걸 막고 싶다면 아래와 같이 구현
@Override
public boolean equals(Object o){
    throw new AssertionError(); // 호출 금지
}
```

equals 메서드를 재정의 할때는 반드시 일반 규약을 따라야한다.
- 반사성(reflexivity) : null이 아닌 모든 참조 값 x에 대해, x.equals(x)는 true
- 대칭성(symmetry) : null이 아닌 모든 참조 값 x, y에 대해, x.equals(y)가 true 일때 y.equals(x)도 true
- 추이성(transitivity) : null이 아닌 모든 참조 값 x, y, z 에 대해 ~
- null 아님 : null이 아닌 모든 참조 값 x에 대해, x.equals(null)은 false 다.

equals 메서드 구현 방법
1. == 연산자를 사용해 입력이 자기 자신의 참조인지 확인한다.
2. instanceof 연산자로 입력이 올바른 타입인지 확인한다.
3. 입력을 올바른 타입으로 형변환한다.
4. 입력 객체와 자기 자신의 대으되는 '핵심' 필드들이 모두 일치하는지 하나씩 검사한다.
5. equals를 재정의 할땐 hashCode도 반드시 재정의한다.
-> 반사성, 대칭성, 추이성, 일관적 확인!


### 아이템 11 : equals를 재정의하려거든 hashCode도 재정의하라

```java
Map<People, String> map = new HashMap<>();
m.put(new People("Daeheekim", 30), "김대희");

m.get(new People("Daeheekim", 30)) -> null!!
```

**-> 더 공부하기(해쉬맵 만드는 거)**


### 아이템 12 : toString을 항상 재정의하라

toString을 잘 구현한 클래스는 사용하기에 훨씬 즐겁고, 그 클래스를 사용한 시스템은 디버깅하기 쉽다.  
그 객체가 가진 주요 정보 모두를 반환하는게 좋다.  
포맷을 명시하는 아니든 여러분의 의도는 명확히 밝혀야 한다.
toString이 반환한 값에 포함된 정보를 얻어올 수 있는 API를 제공하자.


### 아이템 13 : clone 재정의는 주의해서 진행하라

Cloneable을 구현한 클래스는 clone 메서드를 public으로 제공하며, 사용자는 당연히 복제가 제대로 이뤄지지 않으리라 기대한다.  

**-> 더 공부하기(Clone)**

### 아이템 14 : Comparable을 구현할지 고려하라  

compareTo 메서드의 일반 규약
이 객체와 주어진 객체의 순서를 비교한다. 이 객체가 주어진 객체보다 작으면 음의 정수, 같으면 0, 크면 양의정수를 반환한다.  
이 객체와 비교할 수 없는 타입의 객체가 주어지면 ClassCastException을 던진다.  
다음 설명에서 sgn(표현식) 표기는 수학에서 말하는 부호 함수(signum function)를 뜻하며, 표현식의 값이 음수, 0, 양수일 때 -1, 0, 1을 반환 하도록 정의했다.

- 모든 x, y에 대해 sgn(x.comapreTo(y)) == -sgn(y.compareTo(x))여야 한다.
- 추이성을 보장해야 한다. x, y, z ~